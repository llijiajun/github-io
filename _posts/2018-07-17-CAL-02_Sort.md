---
title: 各式排序算法及其c语言实现
author: 冥郡
layout: post
categories: [C,algorithm1]
---

## 问题描述

排序算法可以说是算法的一个基础，这里在我水平范围内进行总结和归纳，并给出我自己实现的源码。

以下，归纳基于比较的排序方法，因此，其运行时间上限基本都是O(nlog(n))

## 程序框架

```{c}
#include<iostream>
#include<vector>
using namespace std;

template <class T>
class Sort{
private:
	vector<T> arrayT;
public:
	Sort(){}
	Sort(vector<T> arr){
		arrayT=arr;//注意这里是深拷贝
	}
	bool compare(T a,T b,bool arise){
		if(arise)
			return (a>b);
		else
			return !(a>b);
	}
	void swap(int i,int j){
		T temp=arrayT[i];
		arrayT[i]=arrayT[j];
		arrayT[j]=temp;
	}
	void print(){
		for(int i=0;i<arrayT.size();i++)
			cout<<arrayT[i]<<" ";
		cout<<endl;
	}
	void bubbleSort(bool arise);//冒泡排序
	void insertSort(bool arise);//插入排序
};

//这里加入冒泡排序部分代码
//这里加入插入排序部分代码

int main(){
	int a[10]={1,3,5,7,9,2,4,6,8,0};
	vector<int> b(a, a+10);
	Sort<int> sortb(b);
	sortb.print();
	sortb.bubbleSort(true);
	sortb.print();
	for(int i=0;i<b.size();i++)
			cout<<b[i]<<" ";
		cout<<endl;
}

```

## 冒泡排序

```{c}
template<class T>
void Sort<T>::bubbleSort(bool arise){
	int n=arrayT.size();
	for(int i=0;i<n-1;i++)
		for(int j=0;j<n-i-1;j++)
			if(compare(arrayT[j],arrayT[j+1],arise))
				swap(j,j+1);
}
```

## 插入排序

```{c}
template<class T>
void Sort<T>::insertSort(bool arise){
	int n=arrayT.size();
	vector<T>::iterator it=arrayT.begin(),in;
	for(int it=1;it<n;it++){
		int flag=0;
		for(in=arrayT.begin();in!=arrayT.begin()+it;in++){
			if(compare(*in,arrayT[it],arise)){
			//找到第一个不满足比较条件的进行插入，这里外循环使用index,内循环使用迭代器与vector的结构有关
			//若外循环也使用迭代器，则会出现bug
			//原因是，在删除元素之后，vector的元素会重构，所有在erase后的元素所在的位置都会改变，所以迭代器指的位置不再是原来的位置，也就形成了空引用
				T temp=arrayT[it];
				arrayT.erase(arrayT.begin()+it);
				arrayT.insert(in,1,temp);
				break;
			}
		}
	}
}
```
